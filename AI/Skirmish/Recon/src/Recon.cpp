/* This file is part of the Spring engine (GPL v2 or later), see LICENSE.html */

#include "Recon.h"


#include "ExternalAI/Interface/AISEvents.h"
#include "ExternalAI/Interface/AISCommands.h"

// generated by the C++ Wrapper scripts
#include "OOAICallback.h"
#include "Unit.h"
#include "UnitDef.h"
#include "Game.h"

#include <string>
#include <iostream>
#include <ostream>

recon::Recon::Recon(springai::OOAICallback* callback):
		callback(callback),
		skirmishAIId(callback != NULL ? callback->GetSkirmishAIId() : -1),
		numPlanes(0),
		reconUnitDef(0),
		hq(0)
		{
		}

recon::Recon::~Recon() {}

static inline std::string IntToString(int i, const std::string& format = "%i")
{
	char buf[64];
	SNPRINTF(buf, sizeof(buf), format.c_str(), i);
	return std::string(buf);
}

static std::ostream& operator <<(std::ostream& ss, springai::AIFloat3 const& vec){
	ss<<vec.x<<","<<vec.y<<","<<vec.z;
	return ss;
}
static std::ostream& operator <<(std::ostream& ss, springai::Unit *const unit){
	springai::UnitDef* unitDef(unit->GetDef());
	ss<<"Unit "<<unitDef->GetType()<<"-"<<unit->GetUnitId()<<":"<<"\n  "
			<< "NAME: "<<unitDef->GetName()<<"\n  "
			<< "HNAME: "<<unitDef->GetHumanName()<<"\n  "
			<< "CATEGORY: "<<unitDef->GetCategoryString()<<"\n  "
			<< "AIR LOS: "<<unitDef->GetAirLosRadius()<<"\n  "
			<< "JAM RADIUS: "<<unitDef->GetJammerRadius()<<"\n  "
			<< "LOS HEIGHT: "<<unitDef->GetLosHeight()<<"\n  "
			<< "LOS RADIUS: "<<unitDef->GetLosRadius()<<"\n  "
			<< "RADAR RADIUS: "<<unitDef->GetRadarRadius()<<"\n  "
			<< "STUNNED: "<<unit->IsParalyzed()<<"\n  "
			<< "ACTIVE: "<<unit->IsActivated()<<"\n  "
			<< "BUILDING: "<<unit->IsBeingBuilt()<<"\n  "
			<< "LOC: "<<unit->GetPos()<<"\n  "
			<< "VEL: "<<unit->GetVel();
	return ss;
}

void recon::Recon::AddPlane(int unitId){
	const std::vector<springai::Unit*> friendlyUnits = callback->GetFriendlyUnits();
	springai::Unit* u(GetFriendlyUnitById(unitId));
	if(u){
		std::string name(u->GetDef()->GetName());
		if(name.find("helicopter")!=std::string::npos){
			u->SetFireState(FIRESTATE_RETURNFIRE);
			u2i[unitId]=numPlanes;
			std::vector<springai::AIFloat3> wpts;
			for(int i=0; i<10; ++i)
				wpts.push_back(springai::AIFloat3(rand()%5000,rand()%2000+100,rand()%5000));
			waypoints.push_back(wpts);
			ustat.push_back(0);

			numPlanes++;
			std::cout << "now have " << this->numPlanes << "planes\n";
			std::cout << u << "\n";
			u->MoveTo(waypoints[u2i[unitId]][++ustat[u2i[unitId]]],0);

		}
	}
}

void recon::Recon::GetUnitById(int id, std::vector<springai::Unit*> const& units, springai::Unit** unit) const{
	for(auto u: units){
		if(id==u->GetUnitId()){
			*unit = u;
			break;
		}
	}
}
springai::Unit* recon::Recon::GetEnemyUnitById(int id) const{
	springai::Unit* ut(0);
	GetUnitById(id,callback->GetEnemyUnits(),&ut);
	return ut;
}
springai::Unit* recon::Recon::GetFriendlyUnitById(int id) const{
	springai::Unit* ut(0);
	GetUnitById(id,callback->GetFriendlyUnits(),&ut);
	return ut;
}
int recon::Recon::HandleEvent(int topic, const void* data) {

	switch (topic) {
		case EVENT_UNIT_CREATED: {
			struct SUnitCreatedEvent* evt = (struct SUnitCreatedEvent*) data;
			int unitId = evt->unit;

	springai::Unit* unit(callback->GetFriendlyUnits()[0]);
	if(unit){
		std::cout << "Moving unit randomly\n";
		for(int i(0);i<10;++i){
			springai::AIFloat3 pos(rand()%10000,rand()%10000,rand()%10000);
			std::cout << "Move to " << pos <<"\n";
			unit->MoveTo(pos,0);
		}
	}
			AddPlane(unitId);

			break;
		}
		case EVENT_COMMAND_FINISHED: {
			struct SCommandFinishedEvent* evt = (struct SCommandFinishedEvent*) data;
			int unitId = evt->unitId;
			springai::Unit* u(GetFriendlyUnitById(unitId));
			std::cout << "Command finished by " << u << "\n";
			if(ustat[u2i[unitId]]>waypoints[u2i[unitId]].size()-1){
				// No more commands... do nothing
			}else if(ustat[u2i[unitId]]>waypoints[u2i[unitId]].size()-2){
				std::cout << "patrol\n";
				// Last command... patrol between points
				u->PatrolTo(waypoints[u2i[unitId]][++ustat[u2i[unitId]]],0);
			}else{
				std::cout << "move\n";
				u->MoveTo(waypoints[u2i[unitId]][++ustat[u2i[unitId]]],0);
			}
			break;
		}
		default: {
			break;
		}
	}

	// signal: everything went OK
	return 0;
}
