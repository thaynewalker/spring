/* This file is part of the Spring engine (GPL v2 or later), see LICENSE.html */

#include "Incumbent.h"
#include "Resource.h"
#include "SkirmishAIs.h"


#include "ExternalAI/Interface/AISEvents.h"
#include "ExternalAI/Interface/AISCommands.h"

// generated by the C++ Wrapper scripts

#include <string>


incumbent::Incumbent::Incumbent(springai::OOAICallback* callback):AIBase(callback){
    strategy=GetIntOption("strategy");
    // strategy:0=defensive - only attack when in high accuracy range; do not actively attack detected targets
    // strategy:1=offensive - attack when in detection range; actively attack detected targets
}

void
incumbent::Incumbent::unitCreatedEvent(SUnitCreatedEvent* evt){
	static const std::string SAM("SAM");
	AIBase::unitCreatedEvent(evt);
	springai::Unit* u(GetFriendlyUnitById(evt->unit));
	if(u->GetDef()->GetTooltip()==SAM){
		u->RadarState(utils::MODE_OFF);
	} else {
	  u->RadarState(utils::MODE_SEARCH);
	}
}


int
incumbent::Incumbent::defaultEvent(int topic, const void* data){
	AIBase::defaultEvent(topic,data);
	if(frame++ % 100) return 0;
	friends=callback->GetFriendlyUnits();
	//if((frame % 10000)==0||deathOccurred) // This really only needs to be updated once in awhile
		//friends=callback->GetFriendlyUnits();

	static const std::string SAM("SAM");
	static const std::string EW("EW");

	std::vector<springai::Unit*> const& enemies(callback->GetEnemyUnits());

	inrangeTable.clear();


	//std::cout << "=================================\n";
		//std::cout << *f << ":" << f->GetRadarState() << "\n";
	springai::Unit* closest(0);
	double dist(9999999999);
	for(auto const e: enemies){
		if(e->GetDef()->GetTooltip()==SAM||e->GetDef()->GetTooltip()==EW)
			continue;
		for(auto const f: friends){
			float d(f->GetPos().distance(e->GetPos()));
			//std::cout << "    Enemy " << *e << uint64_t(e) << " dist = " << d << " < "<< callback->GetWeaponDefByName("rocket")->GetRange() << "\n";
			if(!f->GetDef()){
				f->GetDef();
			}
			if(f->GetRadarState()&&fless(d,dist)){
				dist = d;
				closest=f;
			// Waiting for aircraft to get closer gives SA systems better accuracy (strategy=0)
			}else if(!f->GetRadarState()&&f->GetDef()->GetTooltip()==SAM&&
					fless(d,callback->GetWeaponDefByName("rocket")->GetRange()/**strategy==0?.67:1.0*/)){
				inrangeTable[e].push_back(f);
				//std::cout << " inrange ("<<inrangeTable[e].size()<<") " << d << "<" << callback->GetWeaponDefByName("rocket")->GetRange() << "\n";
			}
		}
	}
	if(inrangeTable.size()){
		for(auto const& e: enemies){ //Radar is currently on...
			// Notify all neighbors who are in range of the entity
			// We assume these entities to be SA vehicles
			for(auto const& neighbor: inrangeTable[e]){
				neighbor->RadarState(utils::MODE_TRACK);
				score-=1; // We lose points for turning on a radar
				callback->GetSkirmishAIs()->SetTheScore(score);
				neighbor->SetMoveState(utils::MOVESTATE_HOLDPOS,0);
				neighbor->SetFireState(utils::FIRESTATE_FIREATWILL,0);
				if(closest)
					std::cout << "COMMS EVENT from " << *closest << " to " << *neighbor << " " << neighbor->GetRadarState()<<"\n";
			}
		}
	}
	std::cout << "Incumbent score: " << score << std::endl;
	return score;
}
